
module
	
	;; a very basic conception to illustrate fundamentally how closures might work simply
	;; by using an argument stack: a list of maps on the heap
	;; consider implementing closures at the library level first before implementing syntax
	;; consider and remember that a nested function could be called externally
	;; so need to maintain a list of stacks per function on entry
	
	directive literals as primitives
	import "../library/utility.watm"
	import "../library/memory.watm"
	import "../library/resource.watm"
	import "../library/system.watm"
	import "../library/string.watm"
	import "../library/number.watm"
	import "../library/boolean.watm"
	import "../library/stack.watm"
	import "../library/list.watm"
	import "../library/vector.watm"
	import "../library/map.watm"
	import "../library/types.watm"
	import "../library/console.watm"
	import "host" "table" (table 1 anyfunc)
	memory (import "host" "memory") 1
	
	function main
		
		system_bootstrap
		test_stack
		print " "
		
	function test_stack
		
		set arguments to (stack_new)
		stack_set arguments "outer.key" "outer.value"
		deep arguments
		print " "
		print ">>> outer stack <<<"
		stack_dump arguments
		stack_exit arguments
		
	function deep accepts arguments
		
		stack_enter arguments
		stack_set arguments "deep.key" "deep.value"
		deeper arguments
		print " "
		print ">>> deep stack <<<"
		stack_dump arguments
		stack_exit arguments
		
	function deeper accepts arguments
		
		stack_enter arguments
		stack_set arguments "deeper.key" "deeper.value"
		deepest arguments
		print " "
		print ">>> deeper stack <<<"
		stack_dump arguments
		stack_exit arguments
		
	function deepest accepts arguments
		
		stack_enter arguments
		stack_set arguments "deepest.key" "deepest.value"
		print " "
		print ">>> deepest stack <<<"
		stack_dump arguments
		stack_exit arguments
		